module Language
  Kotlin = 'kotlin'
  Swift = 'swift'
  Dart = 'dart'

  def self.all
    [Kotlin, Swift, Dart]
  end

  def self.init(language)
    if all.include?(language)
      # Do something with the valid language
    else
      raise ArgumentError, "Invalid language. Please use one of: #{all.join(', ')}"
    end
  end
end

class CodeGenerator
  def initialize(
    json:,
    language:,
    parent_class_name:,
    type_overrides: {}
    )
    @json = json
    @language = language
    @parent_class_name = parent_class_name
    @type_overrides = type_overrides
    @generator = create_language_generator
  end

  def generate
    @generator.generate_content
  end

  private

  def create_language_generator
    case @language
    when Language::Kotlin
      KotlinCodeGenerator.new(@json, @parent_class_name, @type_overrides)
    when Language::Swift
      SwiftCodeGenerator.new(@json, @parent_class_name, @type_overrides)
    when Language::Dart
      DartCodeGenerator.new(@json, @parent_class_name, @type_overrides)
    else
      raise ArgumentError, "Unsupported language: #{@language}"
    end
  end
end

class BaseCodeGenerator
  def initialize(json, parent_class_name, type_overrides)
    @parent_class_name = parent_class_name
    @json = json
    @type_overrides = type_overrides
  end

  def generate_content
    content = "// Generated by Solara\n"
    content += language_specific_imports

    classes = []
    generate_classes(@parent_class_name, @json, classes, generate_json: true)

    classes.reverse_each do |class_content|
      content += class_content
      content += "\n"
    end

    other_classes = language_specific_classes
    other_classes.each do |item|
      content += item
    end

    content + "\n"
  end

  def generate_classes(class_name, json, classes, generate_json: false)
    overridden_type = @type_overrides[class_name] || class_name
    content = class_declaration(overridden_type)
    constructor_params = []

    json.each do |key, value|
      type = overriden_value_type(value, key)
      content += property_declaration(key, type, json)
      constructor_params << constructor_parameter(key, type)
    end

    content += property_declaration("asJson", "String", json)

    content += constructor_declaration(overridden_type, constructor_params)
    content += instance_declaration(overridden_type, json)
    content += json_methods(json, overridden_type)
    content += class_closing

    classes << content

    json.each do |key, value|
      if value.is_a?(Hash)
        nested_class_name = "#{key[0].upcase}#{key[1..-1]}"  # Capitalize first character
        generate_classes(nested_class_name, value, classes)
      elsif value.is_a?(Array) && value.any? { |item| item.is_a?(Hash) }
        nested_class_name = "#{key[0].upcase}#{key[1..-1]}Item"  # Capitalize first character
        generate_classes(nested_class_name, value.first, classes)
      end
    end
  end
  def class_declaration(class_name)
    raise NotImplementedError, "Subclasses must implement class_declaration"
  end

  def property_declaration(key, type, json)
    raise NotImplementedError, "Subclasses must implement property_declaration"
  end

  def color_type
    raise NotImplementedError, "Subclasses must implement property_declaration"
  end

  def constructor_parameter(key, type)
    raise NotImplementedError, "Subclasses must implement constructor_parameter"
  end

  def constructor_declaration(class_name, params)
    raise NotImplementedError, "Subclasses must implement constructor_declaration"
  end

  def instance_declaration(class_name, json)
    raise NotImplementedError, "Subclasses must implement instance_declaration"
  end

  def json_methods(json, class_name)
    raise NotImplementedError, "Subclasses must implement json_methods"
  end

  def class_closing
    raise NotImplementedError, "Subclasses must implement class_closing"
  end

  def language_specific_imports
    raise NotImplementedError, "Subclasses must implement language_specific_imports"
  end

  def value_type(value, class_prefix)
    raise NotImplementedError, "Subclasses must implement value_type"
  end

  def overriden_value_type(value, class_prefix)
    type = value_type(value, class_prefix)
    @type_overrides[type] || type
  end

  def value_for(value, class_prefix, indent)
    raise NotImplementedError, "Subclasses must implement value_for"
  end

  def color_for(value)
    raise NotImplementedError, "Subclasses must implement color_for"
  end

  def language_specific_null
    raise NotImplementedError, "Subclasses must implement language_specific_null"
  end


  def language_specific_classes
    []
  end

end

class KotlinCodeGenerator < BaseCodeGenerator
  def language_specific_imports
    "import android.graphics.Color\n" +
    "import java.io.Serializable\n\n"
  end

  def class_declaration(class_name)
    "\ndata class #{class_name}(\n"
  end

  def property_declaration(key, type, json)
    if key == "asJson"
      json_string = json.to_json.gsub('"', '\\"')
      "  val #{key}: String = \"#{json_string}\",\n"
    elsif json[key].is_a?(String) && ColorDetector.new(json[key]).color?
      "  val #{key}: #{color_type},\n"
    else
      "  val #{key}: #{type},\n"
    end
  end

  def color_type
    "Int"
  end

  def constructor_parameter(key, type)
    "val #{key}: #{type}"
  end

  def constructor_declaration(class_name, params)
    "): Serializable {\n"
  end

  def instance_declaration(class_name, json)
    "  companion object {\n    val instance = #{class_name}(\n#{json.map { |k, v| "      #{k} = #{value_for(v, k, '      ')}" }.join(",\n")}\n    )\n  }\n"
  end

  def json_methods(json, class_name)
    ""
  end

  def class_closing
    "}\n"
  end

  def value_for(value, class_prefix, indent)
    case value
    when String
      if value.start_with?('#') && value.length == 7 # Assume it's a color
        color_for(value)
      else
        "\"#{value}\""  # Use double quotes for Kotlin strings
      end
    when Integer, Float
      value.to_s
    when TrueClass, FalseClass
      value.to_s
    when Array
      if value.empty?
        "emptyList()"  # Use Kotlin's emptyList() for empty arrays
      elsif value.all? { |item| item.is_a?(Hash) }
        array_items = value.map do |item|
          item_values = item.map { |k, v| "#{k} = #{value_for(v, k, indent + '    ')}" }.join(",\n#{indent}    ")
          "#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item(\n#{indent}    #{item_values}\n#{indent}  )"
        end.join(",\n#{indent}  ")
        "listOf(\n#{indent}  #{array_items}\n#{indent})"
      else
        array_items = value.map { |item| value_for(item, class_prefix, indent + '  ') }.join(", ")
        "listOf(\n#{indent}  #{array_items}\n#{indent})"  # Use listOf for non-empty lists
      end
    when Hash
      name = "#{class_prefix[0].upcase}#{class_prefix[1..-1]}"
      overridden_type = @type_overrides[name] || name
      "#{overridden_type}.instance"
    else
      language_specific_null
    end
  end

  def value_type(value, class_prefix)
    case value
    when String
      if ColorDetector.new(value).color?
        return color_type
      end
      return 'String'
    when Integer then 'Int'
    when Float then 'Float'
    when TrueClass, FalseClass then 'Boolean'
    when Array
      if value.empty?
        'List<Any>'
      elsif value.all? { |item| item.is_a?(String) }
        'List<String>'
      elsif value.all? { |item| item.is_a?(Integer) }
        'List<Int>'
      elsif value.all? { |item| item.is_a?(Float) }
        'List<Float>'
      elsif value.all? { |item| item.is_a?(TrueClass) || item.is_a?(FalseClass) }
        'List<Boolean>'
      elsif value.all? { |item| item.is_a?(Hash) }
        "List<#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item>"
      else
        'List<Any>'
      end
    when Hash then "#{class_prefix[0].upcase}#{class_prefix[1..-1]}"
    else 'Any'
    end
  end

  def color_for(value)
    "Color.parseColor(\"#{value}\")"
  end

  def language_specific_null
    'null'
  end
end

class SwiftCodeGenerator < BaseCodeGenerator
  def language_specific_imports
    "import UIKit\n\n"
  end

  def class_declaration(class_name)
    "struct #{class_name}: Codable {\n"
  end

  def property_declaration(key, type, json)
    if key == "asJson"
      json_string = json.to_json.gsub('"', '\\"')
      "  let #{key}: String = \"#{json_string}\"\n"
    elsif json[key].is_a?(String) && ColorDetector.new(json[key]).color?
      "  let #{key}: UIColor\n"
    else
      "  let #{key}: #{type}\n"
    end
  end

  def color_type
    "UIColor"
  end

  def constructor_parameter(key, type)
    "#{key}: #{type}"
  end

  def constructor_declaration(class_name, params)
    "\n  init(\n#{params.map { |p| "       #{p}"}.join(",\n")}) {\n#{params.map { |p| "    self.#{p.split(':').first} = #{p.split(':').first}" }.join("\n")}\n  }\n\n"
  end

  def instance_declaration(class_name, json)
    "  static let shared = #{class_name}(\n#{json.map { |k, v| "    #{k}: #{value_for(v, k, '    ')}" }.join(",\n")}\n  )\n"
  end

  def json_methods(json, class_name)
    coding_keys = json.map { |key, _| "    case #{key}" }.join("\n")

    json_methods = <<-SWIFT
    private enum CodingKeys: String, CodingKey {
    #{coding_keys}
    }

    func toJson() -> String? {
      let encoder = JSONEncoder()
      if let jsonData = try? encoder.encode(self) {
        return String(data: jsonData, encoding: .utf8)
      }
      return nil
    }

    init(from decoder: Decoder) throws {
      let container = try decoder.container(keyedBy: CodingKeys.self)
      #{json.map { |key, value|
        if value.is_a?(String) && ColorDetector.new(value).color?
          "self.#{key} = UIColor(hex: try container.decode(String.self, forKey: .#{key}))"
        else
          "self.#{key} = try container.decode(#{overriden_value_type(value, key)}.self, forKey: .#{key})"
        end
      }.join("\n    ")}
    }

    func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      #{json.map { |key, value|
        if value.is_a?(String) && ColorDetector.new(value).color?
          "try container.encode(self.#{key}.toHexString(), forKey: .#{key})"
        else
          "try container.encode(self.#{key}, forKey: .#{key})"
        end
      }.join("\n    ")}
    }

    static func fromJson(_ json: String) -> #{class_name}? {
      let decoder = JSONDecoder()
      if let jsonData = json.data(using: .utf8),
         let result = try? decoder.decode(#{class_name}.self, from: jsonData) {
        return result
      }
      return nil
    }
    SWIFT

    json_methods
  end

  def class_closing
    "}\n"
  end

  def value_for(value, class_prefix, indent)
    case value
    when String
      if value.start_with?('#') && value.length == 7 # Assume it's a color
        color_for(value)
      else
        "\"#{value}\""
      end
    when Integer, Float
      value.to_s
    when TrueClass, FalseClass
      value.to_s
    when Array
      if value.empty?
        "[]"
      elsif value.all? { |item| item.is_a?(Hash) }
        array_items = value.map do |item|
          item_values = item.map { |k, v| "#{k}: #{value_for(v, k, indent + '    ')}" }.join(",\n#{indent}    ")
          "#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item(\n#{indent}    #{item_values}\n#{indent}  )"
        end.join(",\n#{indent}  ")
        "[\n#{indent}  #{array_items}\n#{indent}]"
      else
        array_items = value.map { |item| value_for(item, class_prefix, indent + '  ') }.join(", ")
        "[\n#{indent}  #{array_items}\n#{indent}]"
      end
    when Hash
      name = "#{class_prefix[0].upcase}#{class_prefix[1..-1]}"
      overridden_type = @type_overrides[name] || name
      "#{overridden_type}.shared"
    else
      language_specific_null
    end
  end

  def value_type(value, class_prefix)
    case value
    when String
      if ColorDetector.new(value).color?
        return color_type
      end
      return 'String'
    when Integer then 'Int'
    when Float then 'Double'
    when TrueClass, FalseClass then 'Bool'
    when Array
      if value.empty?
        '[Any]'
      elsif value.all? { |item| item.is_a?(String) }
        '[String]'
      elsif value.all? { |item| item.is_a?(Integer) }
        '[Int]'
      elsif value.all? { |item| item.is_a?(Float) }
        '[Double]'
      elsif value.all? { |item| item.is_a?(TrueClass) || item.is_a?(FalseClass) }
        '[Bool]'
      elsif value.all? { |item| item.is_a?(Hash) }
        "[#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item]"
      else
        '[Any]'
      end
    when Hash then "#{class_prefix[0].upcase}#{class_prefix[1..-1]}"
    else 'Any'
    end
  end

  def color_for(value)
    r, g, b = value[1..2].to_i(16), value[3..4].to_i(16), value[5..6].to_i(16)
    "UIColor(red: #{r}/255.0, green: #{g}/255.0, blue: #{b}/255.0, alpha: 1.0)"
  end

  def language_specific_null
    'nil'
  end

  def language_specific_classes
    [generate_colors_hex_extension]
  end

  def generate_colors_hex_extension
        <<-SWIFT
        private extension UIColor {
        convenience init(hex: String) {
            let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
            var int: UInt64 = 0
            Scanner(string: hex).scanHexInt64(&int)
            let a, r, g, b: UInt64
            switch hex.count {
            case 3: // RGB (12-bit)
                (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
            case 6: // RGB (24-bit)
                (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
            case 8: // ARGB (32-bit)
                (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
            default:
                (a, r, g, b) = (255, 255, 255, 0)
            }

            self.init(
                red: CGFloat(r) / 255,
                green: CGFloat(g) / 255,
                blue: CGFloat(b) / 255,
                alpha: CGFloat(a) / 255
            )
        }

        func toHexString() -> String {
            guard let components = self.cgColor.components, components.count >= 3 else {
                return "#FFFFFF" // Default to white if the color can't be converted
            }

            let r = Int(components[0] * 255)
            let g = Int(components[1] * 255)
            let b = Int(components[2] * 255)
            let a = components.count > 3 ? Int(components[3] * 255) : 255

            return String(format: "#%02lX%02lX%02lX%02lX", lroundf(Float(a)), lroundf(Float(r)), lroundf(Float(g)), lroundf(Float(b)))
        }
    }
        SWIFT
    end
end

class DartCodeGenerator < BaseCodeGenerator
  def language_specific_imports
    "import 'package:flutter/material.dart';\n" +
    "import 'dart:convert';\n\n"
  end

  def class_declaration(class_name)
    "class #{class_name} {\n"
  end

  def property_declaration(key, type, json)
    if key == "asJson"
      json_string = json.to_json.gsub('"', '\\"')
      "  final String #{key} = \"#{json_string}\";\n"
    elsif json[key].is_a?(String) && ColorDetector.new(json[key]).color?
      "  final Color #{key};\n"
    else
      "  final #{type} #{key};\n"
    end
  end

  def color_type
    "Color"
  end

  def constructor_parameter(key, type)
    "required this.#{key}"
  end

  def constructor_declaration(class_name, params)
    params.empty? ? "\n  const #{class_name}();\n\n" : "\n  const #{class_name}({\n#{params.map { |p| "       #{p}"}.join(",\n")}});\n\n"
  end

  def instance_declaration(class_name, json)
    "  static const #{class_name} instance = #{class_name}(\n#{json.map { |k, v| "    #{k}: #{value_for(v, k, '    ')}" }.join(",\n")}\n  );\n"
  end

  def json_methods(json, class_name)
    "  Map<String, dynamic> toJson() => {\n" +
    "    #{json.keys.map { |k| "'#{k}': #{k}" }.join(",\n    ")}\n" +
    "  };\n\n" +
    "  factory #{class_name}.fromJson(Map<String, dynamic> json) => #{class_name}(\n" +
    "    #{json.keys.map { |k| "#{k}: json['#{k}']" }.join(",\n    ")}\n" +
    "  );\n\n" +
    "  String toJsonString() => jsonEncode(toJson());\n\n" +
    "  factory #{class_name}.fromJsonString(String jsonString) =>\n" +
    "      #{class_name}.fromJson(jsonDecode(jsonString) as Map<String, dynamic>);\n"
  end

  def class_closing
    "}\n"
  end

  def value_for(value, class_prefix, indent)
    case value
    when String
      if value.start_with?('#') && value.length == 7 # Assume it's a color
        color_for(value)
      else
        "\"#{value}\""
      end
    when Integer, Float
      value.to_s
    when TrueClass, FalseClass
      value.to_s
    when Array
      if value.empty?
        "[]"
      elsif value.all? { |item| item.is_a?(Hash) }
        array_items = value.map do |item|
          item_values = item.map { |k, v| "#{k}: #{value_for(v, k, indent + '    ')}" }.join(",\n#{indent}    ")
          "#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item(\n#{indent}    #{item_values}\n#{indent}  )"
        end.join(",\n#{indent}  ")
        "[\n#{indent}  #{array_items}\n#{indent}]"
      else
        array_items = value.map { |item| value_for(item, class_prefix, indent + '  ') }.join(", ")
        "[\n#{indent}  #{array_items}\n#{indent}]"
      end
    when Hash
      name = "#{class_prefix[0].upcase}#{class_prefix[1..-1]}"
      overridden_type = @type_overrides[name] || name
      "#{overridden_type}.instance"
    else
      language_specific_null
    end
  end

  def value_type(value, class_prefix)
    case value
    when String
      if ColorDetector.new(value).color?
        return color_type
      end
      return 'String'
    when Integer then 'int'
    when Float then 'double'
    when TrueClass, FalseClass then 'bool'
    when Array
      if value.empty?
        'List<dynamic>'
      elsif value.all? { |item| item.is_a?(String) }
        'List<String>'
      elsif value.all? { |item| item.is_a?(Integer) }
        'List<int>'
      elsif value.all? { |item| item.is_a?(Float) }
        'List<double>'
      elsif value.all? { |item| item.is_a?(TrueClass) || item.is_a?(FalseClass) }
        'List<bool>'
      elsif value.all? { |item| item.is_a?(Hash) }
        "List<#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item>"
      else
        'List<dynamic>'
      end
    when Hash then "#{class_prefix[0].upcase}#{class_prefix[1..-1]}"
    else 'dynamic'
    end
  end

  def color_for(value)
    "Color(0xFF#{value[1..-1]})"
  end

  def language_specific_null
    'null'
  end
end

class ColorDetector
  attr_accessor :value, :type

  def initialize(value, type = 'string')
    @value = value
    @type = type
  end

  def color?
    hex_color? || rgb_color? || hsl_color? || named_color?
  end

  private

  def hex_color?
    @value.match?(/^#([0-9A-Fa-f]{3}){1,2}$/)
  end

  def rgb_color?
    @value.match?(/^rgb(a)?\([\d%,.\s]+\)$/)
  end

  def hsl_color?
    @value.match?(/^hsl(a)?\([\d%,.\s]+\)$/)
  end

  def named_color?
    %w[red green blue yellow purple orange black white].include?(@value.downcase)
  end
end