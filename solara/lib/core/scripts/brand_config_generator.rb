module Language
  Kotlin = 'kotlin'
  Swift = 'swift'
  Dart = 'dart'

  def self.all
    [Kotlin, Swift, Dart]
  end

  def self.init(language)
    if all.include?(language)
      # Do something with the valid language
    else
      raise ArgumentError, "Invalid language. Please use one of: #{all.join(', ')}"
    end
  end
end

class BrandConfigGenerator
  def initialize(config, output_dir, language, platform)
    @output_dir = output_dir
    @language = language
    @platform = platform
    @config = config
    @generator = create_language_generator
  end

  def generate
    content = @generator.generate_config_content
    FileManager.create_file_if_not_exist(@output_dir)
    File.write(@output_dir, content)
    Solara.logger.debug("Generated brand config #{@output_dir} for: #{@language}")
  end

  private

  def create_language_generator
    case @language
    when Language::Kotlin
      KotlinBrandConfigGenerator.new(@config, @output_dir, @platform)
    when Language::Swift
      SwiftBrandConfigGenerator.new(@config, @output_dir, @platform)
    when Language::Dart
      DartBrandConfigGenerator.new(@config, @output_dir, @platform)
    else
      raise ArgumentError, "Unsupported language: #{@language}"
    end
  end
end

class BaseBrandConfigGenerator
  def initialize(config, output_dir, platform)
    @output_dir = output_dir
    @platform = platform
    @config = config
  end

  def generate_config_content
    content = "// Generated by Solara\n"
    content += language_specific_imports

    classes = []
    generate_classes("BrandConfig", @config, classes)

    classes.reverse_each do |class_content|
      content += class_content
      content += "\n"
    end

    content
  end

  def generate_classes(class_name, config, classes)
    content = class_declaration(class_name)
    constructor_params = []

    config.each do |key, value|
      type = value_type(value, key)
      content += property_declaration(key, type)
      constructor_params << constructor_parameter(key, type)
    end

    content += property_declaration("jsonString", "String")
    constructor_params << constructor_parameter("jsonString", "String")

    content += constructor_declaration(class_name, constructor_params)
    content += instance_declaration(class_name, config)
    content += class_closing

    classes << content

    config.each do |key, value|
      if value.is_a?(Hash)
        nested_class_name = "#{key[0].upcase}#{key[1..-1]}"  # Capitalize first character
        generate_classes(nested_class_name, value, classes)
      elsif value.is_a?(Array) && value.any? { |item| item.is_a?(Hash) }
        nested_class_name = "#{key[0].upcase}#{key[1..-1]}Item"  # Capitalize first character
        generate_classes(nested_class_name, value.first, classes)
      end
    end
  end

  def class_declaration(class_name)
    raise NotImplementedError, "Subclasses must implement class_declaration"
  end

  def property_declaration(key, type)
    raise NotImplementedError, "Subclasses must implement property_declaration"
  end

  def constructor_parameter(key, type)
    raise NotImplementedError, "Subclasses must implement constructor_parameter"
  end

  def constructor_declaration(class_name, params)
    raise NotImplementedError, "Subclasses must implement constructor_declaration"
  end

  def instance_declaration(class_name, config)
    raise NotImplementedError, "Subclasses must implement instance_declaration"
  end

  def class_closing
    raise NotImplementedError, "Subclasses must implement class_closing"
  end

  def language_specific_imports
    raise NotImplementedError, "Subclasses must implement language_specific_imports"
  end

  def value_type(value, class_prefix)
    raise NotImplementedError, "Subclasses must implement value_type"
  end

  def value_for(value, class_prefix, indent)
    case value
    when String
      if value.start_with?('#') && value.length == 7 # Assume it's a color
        color_for(value)
      else
        value.inspect
      end
    when Integer, Float
      value.to_s
    when TrueClass, FalseClass
      value.to_s
    when Array
      if value.empty?
        "[]"
      elsif value.all? { |item| item.is_a?(Hash) }
        array_items = value.map { |item| "#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item.instance" }.join(", ")
        "[\n#{indent}  #{array_items}\n#{indent}]"
      else
        array_items = value.map { |item| value_for(item, class_prefix, indent + '  ') }.join(", ")
        "[\n#{indent}  #{array_items}\n#{indent}]"
      end
    when Hash
      "#{class_prefix[0].upcase}#{class_prefix[1..-1]}.instance"
    else
      language_specific_null
    end
  end

  def color_for(value)
    raise NotImplementedError, "Subclasses must implement color_for"
  end

  def language_specific_null
    raise NotImplementedError, "Subclasses must implement language_specific_null"
  end
end

class KotlinBrandConfigGenerator < BaseBrandConfigGenerator
  def language_specific_imports
    "import android.graphics.Color\n\n"
  end

  def class_declaration(class_name)
    "data class #{class_name}(\n"
  end

  def property_declaration(key, type)
    if key == "jsonString"
      "  val #{key}: String,\n"
    else
      "  val #{key}: #{type},\n"
    end
  end

  def constructor_parameter(key, type)
    if key == "jsonString"
      "val #{key}: String"
    else
      "val #{key}: #{type}"
    end
  end

  def constructor_declaration(class_name, params)
    ") {\n"
  end

  def instance_declaration(class_name, config)
    json_string = config.to_json.gsub('"', '\\"')
    "  companion object {\n    val instance = #{class_name}(\n#{config.map { |k, v| "      #{k} = #{value_for(v, k, '      ')}" }.join(",\n")},\n      jsonString = \"#{json_string}\"\n    )\n  }\n"
  end

  def class_closing
    "}\n"
  end

  def value_for(value, class_prefix, indent)
    case value
    when String
      if value.start_with?('#') && value.length == 7 # Assume it's a color
        color_for(value)
      else
        "\"#{value}\""  # Use double quotes for Kotlin strings
      end
    when Integer, Float
      value.to_s
    when TrueClass, FalseClass
      value.to_s
    when Array
      if value.empty?
        "emptyList()"  # Use Kotlin's emptyList() for empty arrays
      elsif value.all? { |item| item.is_a?(Hash) }
        array_items = value.map { |item| "#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item.instance" }.join(", ")
        "listOf(\n#{indent}  #{array_items}\n#{indent})"  # Use listOf for non-empty lists
      else
        array_items = value.map { |item| value_for(item, class_prefix, indent + '  ') }.join(", ")
        "listOf(\n#{indent}  #{array_items}\n#{indent})"  # Use listOf for non-empty lists
      end
    when Hash
      "#{class_prefix[0].upcase}#{class_prefix[1..-1]}.instance"
    else
      language_specific_null
    end
  end

  def value_type(value, class_prefix)
    case value
    when String then 'String'
    when Integer then 'Int'
    when Float then 'Float'
    when TrueClass, FalseClass then 'Boolean'
    when Array
      if value.empty?
        'List<Any>'
      elsif value.all? { |item| item.is_a?(String) }
        'List<String>'
      elsif value.all? { |item| item.is_a?(Integer) }
        'List<Int>'
      elsif value.all? { |item| item.is_a?(Float) }
        'List<Float>'
      elsif value.all? { |item| item.is_a?(TrueClass) || item.is_a?(FalseClass) }
        'List<Boolean>'
      elsif value.all? { |item| item.is_a?(Hash) }
        "List<#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item>"
      else
        'List<Any>'
      end
    when Hash then "#{class_prefix[0].upcase}#{class_prefix[1..-1]}"
    else 'Any'
    end
  end

  def color_for(value)
    "Color.parseColor(\"#{value}\")"
  end

  def language_specific_null
    'null'
  end
end

class SwiftBrandConfigGenerator < BaseBrandConfigGenerator
  def language_specific_imports
    "import UIKit\n\n"
  end

  def class_declaration(class_name)
    "struct #{class_name} {\n"
  end

  def property_declaration(key, type)
    if key == "jsonString"
      "  let #{key}: String\n"
    else
      "  let #{key}: #{type}\n"
    end
  end

  def constructor_parameter(key, type)
    if key == "jsonString"
      "#{key}: String"
    else
      "#{key}: #{type}"
    end
  end

  def constructor_declaration(class_name, params)
    "\n  init(#{params.join(', ')}) {\n#{params.map { |p| "    self.#{p.split(':').first} = #{p.split(':').first}" }.join("\n")}\n  }\n\n"
  end

  def instance_declaration(class_name, config)
    json_string = config.to_json.gsub('"', '\\"')
    "  static let shared = #{class_name}(\n#{config.map { |k, v| "    #{k}: #{value_for(v, k, '    ')}" }.join(",\n")},\n    jsonString: \"#{json_string}\"\n  )\n"
  end

  def class_closing
    "}\n"
  end

  def value_type(value, class_prefix)
    case value
    when String then 'String'
    when Integer then 'Int'
    when Float then 'Double'
    when TrueClass, FalseClass then 'Bool'
    when Array
      if value.empty?
        '[Any]'
      elsif value.all? { |item| item.is_a?(String) }
        '[String]'
      elsif value.all? { |item| item.is_a?(Integer) }
        '[Int]'
      elsif value.all? { |item| item.is_a?(Float) }
        '[Double]'
      elsif value.all? { |item| item.is_a?(TrueClass) || item.is_a?(FalseClass) }
        '[Bool]'
      elsif value.all? { |item| item.is_a?(Hash) }
        "[#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item]"
      else
        '[Any]'
      end
    when Hash then "#{class_prefix[0].upcase}#{class_prefix[1..-1]}"
    else 'Any'
    end
  end

  def color_for(value)
    r, g, b = value[1..2].to_i(16), value[3..4].to_i(16), value[5..6].to_i(16)
    "UIColor(red: #{r}/255.0, green: #{g}/255.0, blue: #{b}/255.0, alpha: 1.0)"
  end

  def language_specific_null
    'nil'
  end
end

class DartBrandConfigGenerator < BaseBrandConfigGenerator
  def language_specific_imports
    "import 'package:flutter/material.dart';\n\n"
  end

  def class_declaration(class_name)
    "class #{class_name} {\n"
  end

  def property_declaration(key, type)
    if key == "jsonString"
      "  final String #{key};\n"
    else
      "  final #{type} #{key};\n"
    end
  end

  def constructor_parameter(key, type)
    if key == "jsonString"
      "required this.#{key}"
    else
      "required this.#{key}"
    end
  end

  def constructor_declaration(class_name, params)
    params.empty? ? "\n  const #{class_name}();\n\n" : "\n  const #{class_name}({#{params.join(', ')}});\n\n"
  end

  def instance_declaration(class_name, config)
    json_string = config.to_json.gsub('"', '\\"')
    "  static const #{class_name} instance = #{class_name}(\n#{config.map { |k, v| "    #{k}: #{value_for(v, k, '    ')}" }.join(",\n")},\n    jsonString: \"#{json_string}\"\n  );\n"
  end

  def class_closing
    "}\n"
  end

  def value_type(value, class_prefix)
    case value
    when String then 'String'
    when Integer then 'int'
    when Float then 'double'
    when TrueClass, FalseClass then 'bool'
    when Array
      if value.empty?
        'List<dynamic>'
      elsif value.all? { |item| item.is_a?(String) }
        'List<String>'
      elsif value.all? { |item| item.is_a?(Integer) }
        'List<int>'
      elsif value.all? { |item| item.is_a?(Float) }
        'List<double>'
      elsif value.all? { |item| item.is_a?(TrueClass) || item.is_a?(FalseClass) }
        'List<bool>'
      elsif value.all? { |item| item.is_a?(Hash) }
        "List<#{class_prefix[0].upcase}#{class_prefix[1..-1]}Item>"
      else
        'List<dynamic>'
      end
    when Hash then "#{class_prefix[0].upcase}#{class_prefix[1..-1]}"
    else 'dynamic'
    end
  end

  def color_for(value)
    "Color(0xFF#{value[1..-1]})"
  end

  def language_specific_null
    'null'
  end
end